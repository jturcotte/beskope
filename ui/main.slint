import { VerticalBox, Slider, HorizontalBox, GroupBox, TabWidget, ComboBox, LineEdit, GridBox, AboutSlint } from "std-widgets.slint";

enum RenderChannels {
    Single,
    Both,
}

enum PanelLayout {
    TwoPanels,
    SingleTop,
    SingleBottom,
}

enum PanelLayer {
    Overlay,
    Top,
    Bottom,
    Background,
}

struct PanelConfig {
    channels: RenderChannels,
    layout: PanelLayout,
    layer: PanelLayer,
    width: int,
    exclusive_ratio: float,
}

struct WaveformConfig {
    fill_color: color,
    stroke_color: color,
}

export global Configuration {
    callback waveform_config_changed();

    callback panel_channels_changed(PanelConfig);
    callback panel_layout_changed(PanelConfig);
    callback panel_layer_changed(PanelConfig);
    callback panel_width_changed(PanelConfig);
    callback panel_exclusive_ratio_changed(PanelConfig);

    in-out property<WaveformConfig> waveform: {
        fill_color: Colors.rgba(32, 32, 32, 0.8),
        stroke_color: Colors.rgba(205, 205, 205, 0.8),
    };

    in-out property<PanelConfig> panel: {
        channels: RenderChannels.Both,
        layout: PanelLayout.TwoPanels,
        layer: PanelLayer.Top,
        width: 80,
        exclusive_ratio: 0.5,
    };
}

component LabeledSlider {
    in-out property<float> value <=> slider.value;
    in property<string> label <=> text.text;
    in property<float> minimum <=> slider.minimum;
    in property<float> maximum <=> slider.maximum;
    in property<float> precision: 100;
    in property<string> unit: "";
    callback changed(float);
    HorizontalBox {
        text := Text {
            vertical-alignment: TextVerticalAlignment.center;
        }
        slider := Slider {
            changed(value) => { changed(value) }
        }
        Text {
            width: 10%;
            text: round(value*precision)/precision + root.unit;
            vertical-alignment: TextVerticalAlignment.center;
            horizontal-alignment: TextHorizontalAlignment.left;
        }
    }
}


component HsvColorSelection inherits GroupBox {
    in-out property<float> h <=> h_slider.value;
    in-out property<float> s <=> s_slider.value;
    in-out property<float> v <=> v_slider.value;
    in-out property<float> a <=> a_slider.value;
    callback changed();
    VerticalBox {
        h_slider := LabeledSlider {
            label: "H";
            maximum: 359.999;
            changed(value) => { changed() }
        }
        s_slider := LabeledSlider {
            label: "S";
            maximum: 1.0;
            changed(value) => { changed() }
        }
        v_slider := LabeledSlider {
            label: "V";
            maximum: 1.0;
            changed(value) => { changed() }
        }
        a_slider := LabeledSlider {
            label: "A";
            maximum: 1.0;
            changed(value) => { changed() }
        }
    }
}

export component ConfigurationWindow inherits Window {
    function update_waveform_config() {
        Configuration.waveform.fill_color = Colors.hsv(fill_color.h, fill_color.s, fill_color.v, fill_color.a);
        Configuration.waveform.stroke_color = Colors.hsv(stroke_color.h, stroke_color.s, stroke_color.v, stroke_color.a);
        Configuration.waveform_config_changed();
    }

    preferred-width: 800px;
    preferred-height: 600px;

    TabWidget {
        Tab {
            title: "General";
            GridBox {
                Row {
                    Text {
                        text: "Channels per window/panel";
                        vertical-alignment: TextVerticalAlignment.center;
                    }
                    channels_cb := ComboBox {
                        enabled: layout_cb.current-value != "Two panels (one on each side of the screen)";
                        model: [
                            "Only left",
                            "Both left and right",
                        ];
                        current-index: Configuration.panel.channels == RenderChannels.Single ? 0 : 1;
                        selected(current-value) => {
                            if (self.current-index == 0) {
                                Configuration.panel.channels = RenderChannels.Single;
                            } else {
                                Configuration.panel.channels = RenderChannels.Both;
                            }
                            Configuration.panel_channels_changed(Configuration.panel);
                        }
                    }
                }
                Row {
                    Text {
                        text: "Panel layout";
                        vertical-alignment: TextVerticalAlignment.center;
                    }
                    layout_cb := ComboBox {
                        model: [
                            "Two panels (one on each side of the screen)",
                            "Single panel at the top",
                            "Single panel at the bottom",
                        ];
                        current-index: Configuration.panel.layout == PanelLayout.TwoPanels
                            ? 0 
                            : Configuration.panel.layout == PanelLayout.SingleTop
                                ? 1
                                : 2;
                        selected(current-value) => {
                            if (self.current-index == 0) {
                                channels_cb.enabled = false;
                                channels_cb.current-index = 0;
                            } else {
                                channels_cb.enabled = true;
                            }

                            if (self.current-index == 0) {
                                Configuration.panel.layout = PanelLayout.TwoPanels;
                            } else if (self.current-index == 1) {
                                Configuration.panel.layout = PanelLayout.SingleTop;
                            } else {
                                Configuration.panel.layout = PanelLayout.SingleBottom;
                            }
                            Configuration.panel_layout_changed(Configuration.panel);
                        }
                    }
                }
                Row {
                    Text {
                        text: "Panel Layer";
                        vertical-alignment: TextVerticalAlignment.center;
                    }
                    layer_cb := ComboBox {
                        model: [
                            "Overlay",
                            "Top",
                            "Bottom",
                            "Background",
                        ];
                        current-index: Configuration.panel.layer == PanelLayer.Overlay
                            ? 0
                            : Configuration.panel.layer == PanelLayer.Top
                                ? 1
                                : Configuration.panel.layer == PanelLayer.Bottom
                                    ? 2
                                    : 3;
                        selected(current-value) => {
                            if (self.current-index == 0) {
                                Configuration.panel.layer = PanelLayer.Overlay;
                            } else if (self.current-index == 1) {
                                Configuration.panel.layer = PanelLayer.Top;
                            } else if (self.current-index == 2) {
                                Configuration.panel.layer = PanelLayer.Bottom;
                            } else {
                                Configuration.panel.layer = PanelLayer.Background;
                            }
                            Configuration.panel_layer_changed(Configuration.panel);
                        }
                    }
                }
                Row {
                    Text { text: "Height/Width"; }
                    LabeledSlider {
                        value: Configuration.panel.width;
                        minimum: 1;
                        maximum: 800;
                        precision: 1;
                        unit: " px";
                        changed => {
                            Configuration.panel.width = self.value;
                            Configuration.panel_width_changed(Configuration.panel);
                        }
                    }
                }
                Row {
                    Text { text: "Height/Width Exclusive"; }
                    LabeledSlider {
                        value: Configuration.panel.exclusive_ratio * 100;
                        minimum: 0;
                        maximum: 100;
                        precision: 1;
                        unit: " %";
                        changed => {
                            Configuration.panel.exclusive_ratio = self.value / 100;
                            Configuration.panel_exclusive_ratio_changed(Configuration.panel);
                        }
                    }
                }
                Rectangle { }
            }
        }
        Tab {
            title: "Color";
            VerticalBox {
                fill_color := HsvColorSelection {
                    changed => { update_waveform_config(); }
                    title: "Fill";
                    h: Configuration.waveform.fill_color.to_hsv().hue;
                    s: Configuration.waveform.fill_color.to_hsv().saturation;
                    v: Configuration.waveform.fill_color.to_hsv().value;
                    a: Configuration.waveform.fill_color.to_hsv().alpha;
                }
                stroke_color := HsvColorSelection {
                    title: "Stroke";
                    changed => { update_waveform_config(); }
                    h: Configuration.waveform.stroke_color.to_hsv().hue;
                    s: Configuration.waveform.stroke_color.to_hsv().saturation;
                    v: Configuration.waveform.stroke_color.to_hsv().value;
                    a: Configuration.waveform.stroke_color.to_hsv().alpha;
                }
            }
        }
    }
}
